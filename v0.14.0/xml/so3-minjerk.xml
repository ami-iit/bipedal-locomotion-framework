<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="so3-minjerk" kind="page">
    <compoundname>so3-minjerk</compoundname>
    <title>üßÆ SO3 Minimum jerk trajectory</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="so3-minjerk_1md__home_runner_work_bipedal_locomotion_framework_bipedal_locomotion_framework_docs_bipedal_locomotion_framework_docs_pages_so3_minjerk"/> </para>
<sect1 id="so3-minjerk_1autotoc_md4">
<title>Introduction</title>
<para>Planning a minimum jerk trajectory in SO(3) can be a complex task. In this document, we aim to demonstrate the capabilities of the <bold>bipedal-locomotion-framework</bold> for generating minimum jerk trajectories in SO(3). The document is structured as follows: we first provide an overview of the mathematical foundations behind the planner, followed by a simple example illustrating its usage. Finally, we recommend some interesting readings for readers seeking more in-depth explanations and rigorous proofs.</para>
</sect1>
<sect1 id="so3-minjerk_1autotoc_md5">
<title>üìê Math</title>
<para>Given a fixed initial rotation <formula id="0">$(t_0, R_0)$</formula> and a final rotation <formula id="1">$(t_f, R_f)$</formula> and the associated left trivialized angular velocities, <formula id="2">$(t_0, \omega_0)$</formula> and <formula id="3">$(t_f, \omega_f)$</formula>, we want to compute a trajectory <formula id="4">$R : \mathbb{R}_+ \rightarrow SO(3)$</formula> such that <formula id="5">$R(t_0) = R_0$</formula>, <formula id="6">$R(t_f) = R_f$</formula>, <formula id="7">$\omega(t_0) = \omega_0$</formula>, <formula id="8">$\omega(t_f) = \omega_f$</formula>, <formula id="9">$\dot{\omega}(t_0) = \dot{\omega}_0$</formula>, <formula id="10">$\dot{\omega}(t_f) = \dot{\omega}_f$</formula> such that left trivialized angular jerk is minimized</para>
<para><formula id="11">\[ \mathfrak{G} = \int_{t_0}^{t_f} \left({}^\mathcal{F} \ddot{\omega} _ {\mathcal{I}, F}^\top {}^\mathcal{F} \ddot{\omega} _ {\mathcal{I}, F} \right)\text{d} t. \]</formula></para>
<para>Following the work of <ulink url="https://doi.org/10.1109/70.704225">Zefran et al. &quot;On the Generation of Smooth Three-Dimensional Rigid Body Motions&quot;</ulink> it is possible to prove that a trajectory <formula id="12">$R(t)$</formula> that satisfies the following equation is a minimum jerk trajectory in SO(3).</para>
<para><formula id="13">\[ \begin{array}{ll} \omega ^{(5)} &amp; + 2 \omega \times \omega ^{(4)} \\ &amp; + \frac{4}{5} \omega \times (\omega \times \omega ^{(3)}) + \frac{5}{2} \dot{\omega} \times \omega^{(3)} \\ &amp; + \frac{1}{4} \omega \times (\omega \times (\omega \times \ddot{\omega})) \\ &amp; + \frac{3}{2} \omega \times (\dot{\omega} \times \ddot{\omega}) \\ &amp; - (\omega \times \ddot{\omega}) \times \dot{\omega} \\ &amp; - \frac{1}{4} (\omega \times \dot{\omega}) \times \ddot{\omega} \\ &amp; - \frac{3}{8} \omega \times ((\omega \times \dot{\omega}) \times \dot{\omega}) \\ &amp; - \frac{1}{8} (\omega \times (\omega \times \dot{\omega})) \times \dot{\omega} = 0. \end{array} \]</formula></para>
<para>From now on we call this condition: <bold>Minimum jerk trajectory condition</bold>.</para>
<para>It is worth noting that the above does not admit an analytic solution for arbitrary boundary conditions. However, in the case of zero boundary velocity and acceleration or specific structure of the boundary condition, it is possible to show that <formula id="14">\[ R(t) = R_{0} \exp{\left(s(t-t_0) \log\left(R_0^\top R_f \right) \right)} \quad \quad s(\tau) = a_5 \tau^5 + a_4 \tau^4 + a_3 \tau^3 + a_2 \tau^2 + a_1 \tau + a_0 \]</formula> satisfies condition the minimum jerk necessary condition. To prove the latest statement, we assume that <formula id="15">$t_0 = 0$</formula> and <formula id="16">$t_1 = 1$</formula>, and then we compute the left trivialized angular velocity. The assumption can be easily removed with a simple change of variables.</para>
<para>The angular velocity is given by</para>
<para><formula id="17">\[ \begin{array}{ll} \omega^\wedge &amp;= R^\top \dot{R} \\ &amp;= \dot{s} \exp{\left(-s\log\left( R _ 0^\top R _ f \right) \right)}R_{0} ^\top R _ {0} \log\left( R _ 0^\top R _ f \right) \exp{\left(s\log\left( R _ 0^\top R _ f \right) \right)} \\ &amp;= \dot{s}\exp{\left(-s\log\left(R _ 0^\top R _ f \right) \right)} \log\left( R _ 0^\top R _ f \right) \exp{\left(s\log\left( R _ 0^\top R _ f \right) \right)} \\ &amp;= \dot{s}\exp{\left(-s\log\left(R _ 0^\top R _ f \right) \right)} \exp{\left(s\log\left( R _ 0^\top R _ f \right) \right)} \log\left( R _ 0^\top R _ f \right) \\ &amp;= \dot{s} \log\left( R _ 0^\top R _ f \right). \end{array} \]</formula></para>
<para>In other words, the angular velocity will be always proportional to <formula id="18">$\log\left( R_0^\top R_f \right)$</formula>.</para>
<para>This means that we can ask for an initial and final angular velocity that is linearly dependent on <formula id="19">$\log\left(R_0^\top R_f \right)$</formula>. Let us introduce <formula id="20">$\omega^\wedge(0)$</formula> and <formula id="21">$\omega^\wedge(1)$</formula> as</para>
<para><formula id="22">\[ \omega^\wedge(0) = \lambda ^\omega _ 0 \log\left( R_0^\top R_f \right) \quad \omega^\wedge(1) = \lambda ^\omega _ 1 \log\left( R_0^\top R_f \right) \]</formula></para>
<para>similarly for the angular acceleration</para>
<para><formula id="23">\[ \dot{\omega}^\wedge(0) = \lambda ^\alpha _ 0 \log\left( R_0^\top R_f \right) \quad \dot{\omega}^\wedge(1) = \lambda ^\alpha _ 1 \log\left( R_0^\top R_f \right) \]</formula></para>
<para>So combining the initial and the final boundary conditions we can write the following linear system. <formula id="24">\[ \begin{array}{ll} s(0) &amp;= 0 \\ s(1) &amp;= 1 \\ \dot{s}(0) &amp;= \lambda ^\omega _ 0 \\ \dot{s}(1) &amp;= \lambda ^\omega _ 1 \\ \ddot{s}(0) &amp;= \lambda ^\alpha _ 0 \\ \ddot{s}(1) &amp;= \lambda ^\alpha _ 1 \end{array} \]</formula></para>
<para>Solving the above system we obtain</para>
<para><formula id="25">\[ \begin{array}{ll} a_0 &amp;= 0 \\ a_1 &amp;= \lambda ^\omega _ 0 \\ a_2 &amp;= \lambda ^\alpha _ 0/2 \\ a_3 &amp;= \lambda ^\alpha _ 1/2 - (3 \lambda ^\alpha _ 0)/2 - 6 \lambda ^\omega _ 0 - 4 \lambda ^\omega _ 1 + 10 \\ a_4 &amp;= (3 \lambda ^\alpha _ 0)/2 - \lambda ^\alpha _ 1 + 8 \lambda ^\omega _ 0 + 7 \lambda ^\omega _ 1 - 15 \\ a_5 &amp;= \lambda ^\alpha _ 1/2 - \lambda ^\alpha _ 0/2 - 3 \lambda ^\omega _ 0 - 3 \lambda ^\omega _ 1 + 6 \end{array} \]</formula></para>
<para>It is now easy to show that <formula id="26">$\omega$</formula> satisfies the minimum jerk condition indeed</para>
<para><formula id="27">\[ \omega ^{(5)} = 0 \]</formula></para>
<para>and all the cross products vanish since the angular velocity and its derivatives are linearly dependent.</para>
</sect1>
<sect1 id="so3-minjerk_1autotoc_md6">
<title>üíª How to use the planner</title>
<para>The SO3 minimum jerk planner is provided in <bold>bipedal-locomotion-framework</bold> through a template class that allows the user to use the left or the right trivialized angular velocity</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal">std::chrono_literals;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">manif::SO3d<sp/>initialTransform<sp/>=<sp/>manif::SO3d::Random();</highlight></codeline>
<codeline><highlight class="normal">manif::SO3d<sp/>finalTransform<sp/>=<sp/>manif::SO3d::Random();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">constexpr<sp/>std::chrono::nanoseconds<sp/>T<sp/>=<sp/>1s;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">BipedalLocomotion::Planner::SO3PlannerInertial<sp/>planner;</highlight></codeline>
<codeline><highlight class="normal">manif::SO3d::Tangent<sp/>initialVelocity<sp/>=<sp/>(finalTransform<sp/>*<sp/>initialTransform.inverse()).<ref refid="namespaceBipedalLocomotion_1a0262a6287c9047d721fc7809c2be667c" kindref="member">log</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">initialVelocity.coeffs()<sp/>=<sp/>initialVelocity.coeffs()<sp/>*<sp/>2;</highlight></codeline>
<codeline><highlight class="normal">planner.setInitialConditions(initialVelocity,<sp/>manif::SO3d::Tangent::Zero());</highlight></codeline>
<codeline><highlight class="normal">planner.setFinalConditions(manif::SO3d::Tangent::Zero(),<sp/>manif::SO3d::Tangent::Zero());</highlight></codeline>
<codeline><highlight class="normal">planner.setRotations(initialTransform,<sp/>finalTransform,<sp/>T);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">manif::SO3d<sp/>rotation,<sp/>predictedRotation;</highlight></codeline>
<codeline><highlight class="normal">manif::SO3d::Tangent<sp/>velocity,<sp/>predictedVelocity;</highlight></codeline>
<codeline><highlight class="normal">manif::SO3d::Tangent<sp/>acceleration;</highlight></codeline>
<codeline><highlight class="normal">planner.evaluatePoint(0.42s,<sp/>rotation,<sp/>velocity,<sp/>acceleration);</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="so3-minjerk_1autotoc_md7">
<title>üìñ Interesting readings</title>
<para>The interested reader can refer to the extensive literature, among which it is worth mentioning:</para>
<para><itemizedlist>
<listitem><para>≈Ωefran, M., Kumar, V., and Croke, C. (1998). <emphasis>On the generation of smooth threedimensional rigid body motions</emphasis>. IEEE Transactions on Robotics and Automation, 14(4):576‚Äì589.</para>
</listitem><listitem><para>Dubrovin, B. A., Fomenko, A. T., and Novikov, S. P. (1984). <emphasis>Modern Geometry ‚Äî Methods and Applications, volume 93</emphasis>. Springer New York, New York, NY.</para>
</listitem><listitem><para>Needham, T. (2021). <emphasis>Visual Differential Geometry and Forms</emphasis>. Princeton University Press.</para>
</listitem><listitem><para>Pressley, A. (2010). <emphasis>Elementary Differential Geometry</emphasis>. Springer London, London.</para>
</listitem><listitem><para>Giulio Romualdi (2022) <emphasis>Online Control of Humanoid Robot Locomotion</emphasis> Ph.D. Thesis. </para>
</listitem></itemizedlist>
</para>
</sect1>
    </detaileddescription>
    <location file="/home/runner/work/bipedal-locomotion-framework/bipedal-locomotion-framework/docs/bipedal-locomotion-framework/docs/pages/so3-minjerk.md"/>
  </compounddef>
</doxygen>
