<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl" kind="class" language="C++" prot="public">
    <compoundname>BipedalLocomotion::RobotInterface::YarpRobotControl</compoundname>
    <basecompoundref refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl" prot="public" virt="non-virtual">BipedalLocomotion::RobotInterface::IRobotControl</basecompoundref>
    <includes local="no">BipedalLocomotion/RobotInterface/YarpRobotControl.h</includes>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1afafcb9039f5ae8deaac0d3ca95258dd1" prot="private" static="no" mutable="no">
        <type>std::unique_ptr&lt; Impl &gt;</type>
        <definition>std::unique_ptr&lt;Impl&gt; BipedalLocomotion::RobotInterface::YarpRobotControl::m_pimpl</definition>
        <argsstring></argsstring>
        <name>m_pimpl</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="BipedalLocomotion/RobotInterface/YarpRobotControl.h" line="37" column="21" bodyfile="BipedalLocomotion/RobotInterface/YarpRobotControl.h" bodystart="36" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a4ec6b9d2a7d24b197431776c257d7c50" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>BipedalLocomotion::RobotInterface::YarpRobotControl::YarpRobotControl</definition>
        <argsstring>()</argsstring>
        <name>YarpRobotControl</name>
        <briefdescription>
<para>Constructor. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="BipedalLocomotion/RobotInterface/YarpRobotControl.h" line="43" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a85dbd7d4b6312bf184bb03054a0240b5" prot="public" static="no" const="no" explicit="no" inline="no" final="yes" virt="virtual">
        <type>bool</type>
        <definition>bool BipedalLocomotion::RobotInterface::YarpRobotControl::initialize</definition>
        <argsstring>(std::weak_ptr&lt; ParametersHandler::IParametersHandler &gt; handler) final</argsstring>
        <name>initialize</name>
        <reimplements refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1ae6bb2f00cd191a0cc65c062928b65327">initialize</reimplements>
        <param>
          <type>std::weak_ptr&lt; <ref refid="classBipedalLocomotion_1_1ParametersHandler_1_1IParametersHandler" kindref="compound">ParametersHandler::IParametersHandler</ref> &gt;</type>
          <declname>handler</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>   Initialize the Interface
   @param handler pointer to a parameter handler interface
   @note the following parameters are required by the class
   |             Parameter name             |   Type   |                                          Description                                         | Mandatory |
   |:--------------------------------------:|:--------:|:--------------------------------------------------------------------------------------------:|:---------:|
   |            `reading_timeout`           |   `int`  |    Timeout used while reading from the YARP interfaces in microseconds. (Positive Number)    |     No    |
   |         `max_reading_attempts`         |   `int`  |      Max number of attempts used for reading from the YARP interfaces. (Positive Number)     |     No    |
   |         `positioning_duration`         | `double` | Duration of the trajectory generated when the joint is controlled in position mode [seconds] |    Yes    |
   |         `positioning_tolerance`        | `double` |                    Max Admissible error for position control joint [rad]                     |    Yes    |
   | `position_direct_max_admissible_error` | `double` |                 Max admissible error for position direct control joint [rad]                 |    Yes    |
   @return True/False in case of success/failure.
</verbatim> clang-format on </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="BipedalLocomotion/RobotInterface/YarpRobotControl.h" line="60" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a37085e21adddb1bc55193d452623fc82" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool BipedalLocomotion::RobotInterface::YarpRobotControl::setDriver</definition>
        <argsstring>(std::shared_ptr&lt; yarp::dev::PolyDriver &gt; robotDevice)</argsstring>
        <name>setDriver</name>
        <param>
          <type>std::shared_ptr&lt; yarp::dev::PolyDriver &gt;</type>
          <declname>robotDevice</declname>
        </param>
        <briefdescription>
<para>Set the driver required to control the robot. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>robotDevice</parametername>
</parameternamelist>
<parameterdescription>
<para>device used to control the robot. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True/False in case of success/failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="BipedalLocomotion/RobotInterface/YarpRobotControl.h" line="67" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a69d3aac94055729d5fbff666ae1ceb83" prot="public" static="no" const="no" explicit="no" inline="no" final="yes" virt="virtual">
        <type>bool</type>
        <definition>bool BipedalLocomotion::RobotInterface::YarpRobotControl::checkMotionDone</definition>
        <argsstring>(bool &amp;motionDone, bool &amp;isTimeExpired, std::vector&lt; std::pair&lt; std::string, double &gt;&gt; &amp;info) final</argsstring>
        <name>checkMotionDone</name>
        <reimplements refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1a1d8c631649d6111f17a9ba821f550497">checkMotionDone</reimplements>
        <param>
          <type>bool &amp;</type>
          <declname>motionDone</declname>
        </param>
        <param>
          <type>bool &amp;</type>
          <declname>isTimeExpired</declname>
        </param>
        <param>
          <type>std::vector&lt; std::pair&lt; std::string, double &gt;&gt; &amp;</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>Check if the motion set through the position control mode ended. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">motionDone</parametername>
</parameternamelist>
<parameterdescription>
<para>true if the motion ended. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">isTimerExpired</parametername>
</parameternamelist>
<parameterdescription>
<para>true if the internal timer is expired or not. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">info</parametername>
</parameternamelist>
<parameterdescription>
<para>vector containing the list of the joint whose motion did not finish yet. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True/False in case of success/failure. </para>
</simplesect>
<simplesect kind="note"><para>If the timer is expired and the motion did not finish yet, there may be a problem with the robot. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="BipedalLocomotion/RobotInterface/YarpRobotControl.h" line="78" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1afe135a4312087eb0b666ddbbe3dc25bf" prot="public" static="no" const="no" explicit="no" inline="no" final="yes" virt="virtual">
        <type>bool</type>
        <definition>bool BipedalLocomotion::RobotInterface::YarpRobotControl::setControlMode</definition>
        <argsstring>(const std::vector&lt; IRobotControl::ControlMode &gt; &amp;controlModes) final</argsstring>
        <name>setControlMode</name>
        <reimplements refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1a1510d2b72ba39e075a078b2275c7a988">setControlMode</reimplements>
        <param>
          <type>const std::vector&lt; <ref refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1a4d0ff64a201bf8ed884da1c41e3497bc" kindref="member">IRobotControl::ControlMode</ref> &gt; &amp;</type>
          <declname>controlModes</declname>
        </param>
        <briefdescription>
<para>Set the control mode. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>controlModes</parametername>
</parameternamelist>
<parameterdescription>
<para>vector containing the control mode for each joint. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True/False in case of success/failure. </para>
</simplesect>
<simplesect kind="warning"><para>At the current stage only revolute joints are supported. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="BipedalLocomotion/RobotInterface/YarpRobotControl.h" line="88" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1acdbfb92bd7a2a6bc31ba156600a4ffc9" prot="public" static="no" const="no" explicit="no" inline="no" final="yes" virt="virtual">
        <type>bool</type>
        <definition>bool BipedalLocomotion::RobotInterface::YarpRobotControl::setControlMode</definition>
        <argsstring>(const IRobotControl::ControlMode &amp;mode) final</argsstring>
        <name>setControlMode</name>
        <reimplements refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1a5ae1dad766c79a234c67b53823bbd77a">setControlMode</reimplements>
        <param>
          <type>const <ref refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1a4d0ff64a201bf8ed884da1c41e3497bc" kindref="member">IRobotControl::ControlMode</ref> &amp;</type>
          <declname>mode</declname>
        </param>
        <briefdescription>
<para>Set the desired control mode. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>controlMode</parametername>
</parameternamelist>
<parameterdescription>
<para>a control mode for all the joints. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True/False in case of success/failure. </para>
</simplesect>
<simplesect kind="warning"><para>Call this function if you want to control all the joint with the same control mode. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="BipedalLocomotion/RobotInterface/YarpRobotControl.h" line="96" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a227ecb6dd23de07c9513b5f0d6fd3704" prot="public" static="no" const="no" explicit="no" inline="no" final="yes" virt="virtual">
        <type>std::future&lt; bool &gt;</type>
        <definition>std::future&lt;bool&gt; BipedalLocomotion::RobotInterface::YarpRobotControl::setControlModeAsync</definition>
        <argsstring>(const std::vector&lt; IRobotControl::ControlMode &gt; &amp;controlModes) final</argsstring>
        <name>setControlModeAsync</name>
        <reimplements refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1a1970510914cde2aca6afde023c57692e">setControlModeAsync</reimplements>
        <param>
          <type>const std::vector&lt; <ref refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1a4d0ff64a201bf8ed884da1c41e3497bc" kindref="member">IRobotControl::ControlMode</ref> &gt; &amp;</type>
          <declname>controlModes</declname>
        </param>
        <briefdescription>
<para>Set the control mode in an asynchronous thread. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>controlModes</parametername>
</parameternamelist>
<parameterdescription>
<para>vector containing the control mode for each joint. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An std::future object to a boolean True/False in case of success/failure. </para>
</simplesect>
<simplesect kind="warning"><para>At the current stage only revolute joints are supported. Since this function spawns a new thread, the invoking thread is not blocked. Note that this function is not thread safe. You should check the future object status before calling other functions like <ref refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a6e9c89964582229a11b5944e02ba6017" kindref="member">setReferences()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="BipedalLocomotion/RobotInterface/YarpRobotControl.h" line="108" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a7f2ccdd46451cf760928e527ac2e34b7" prot="public" static="no" const="no" explicit="no" inline="no" final="yes" virt="virtual">
        <type>std::future&lt; bool &gt;</type>
        <definition>std::future&lt;bool&gt; BipedalLocomotion::RobotInterface::YarpRobotControl::setControlModeAsync</definition>
        <argsstring>(const IRobotControl::ControlMode &amp;mode) final</argsstring>
        <name>setControlModeAsync</name>
        <reimplements refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1a1a80321643730fb837ca1373e241dcd8">setControlModeAsync</reimplements>
        <param>
          <type>const <ref refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1a4d0ff64a201bf8ed884da1c41e3497bc" kindref="member">IRobotControl::ControlMode</ref> &amp;</type>
          <declname>mode</declname>
        </param>
        <briefdescription>
<para>Set the desired control mode in an asynchronous thread. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>controlMode</parametername>
</parameternamelist>
<parameterdescription>
<para>a control mode for all the joints. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An std::future object to a boolean True/False in case of success/failure. </para>
</simplesect>
<simplesect kind="warning"><para>Call this function if you want to control all the joint with the same control mode. Since this function spawns a new thread, the invoking thread is not blocked. Note that this function is not thread safe. You should check the future object status before calling other functions like <ref refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a6e9c89964582229a11b5944e02ba6017" kindref="member">setReferences()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="BipedalLocomotion/RobotInterface/YarpRobotControl.h" line="119" column="17"/>
      </memberdef>
      <memberdef kind="function" id="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a6e9c89964582229a11b5944e02ba6017" prot="public" static="no" const="no" explicit="no" inline="no" final="yes" virt="virtual">
        <type>bool</type>
        <definition>bool BipedalLocomotion::RobotInterface::YarpRobotControl::setReferences</definition>
        <argsstring>(Eigen::Ref&lt; const Eigen::VectorXd &gt; desiredJointValues, const std::vector&lt; IRobotControl::ControlMode &gt; &amp;controlModes, std::optional&lt; Eigen::Ref&lt; const Eigen::VectorXd &gt;&gt; currentJointValues={}) final</argsstring>
        <name>setReferences</name>
        <reimplements refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1ade3791093f875c8a242c0e84dcc5a40b">setReferences</reimplements>
        <param>
          <type>Eigen::Ref&lt; const Eigen::VectorXd &gt;</type>
          <declname>desiredJointValues</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1a4d0ff64a201bf8ed884da1c41e3497bc" kindref="member">IRobotControl::ControlMode</ref> &gt; &amp;</type>
          <declname>controlModes</declname>
        </param>
        <param>
          <type>std::optional&lt; Eigen::Ref&lt; const Eigen::VectorXd &gt;&gt;</type>
          <declname>currentJointValues</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Set the desired reference. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>desiredJointValues</parametername>
</parameternamelist>
<parameterdescription>
<para>desired joint values. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>controlModes</parametername>
</parameternamelist>
<parameterdescription>
<para>vector containing the control mode for each joint. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True/False in case of success/failure. </para>
</simplesect>
<simplesect kind="note"><para>In case of position control the values has to be expressed in rad, in case of velocity control in rad/s. If the robot is controlled in torques, the desired joint values are expressed in Nm. If the robot is controlled in PWM, the desired joint values are between -100 and 100. </para>
</simplesect>
<simplesect kind="warning"><para>At the current stage only revolute joints are supported. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="BipedalLocomotion/RobotInterface/YarpRobotControl.h" line="133" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1ad19d7c06a0f9acd3685075595660a2d7" prot="public" static="no" const="no" explicit="no" inline="no" final="yes" virt="virtual">
        <type>bool</type>
        <definition>bool BipedalLocomotion::RobotInterface::YarpRobotControl::setReferences</definition>
        <argsstring>(Eigen::Ref&lt; const Eigen::VectorXd &gt; desiredJointValues, const IRobotControl::ControlMode &amp;mode, std::optional&lt; Eigen::Ref&lt; const Eigen::VectorXd &gt;&gt; currentJointValues={}) final</argsstring>
        <name>setReferences</name>
        <reimplements refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1ad8e86bfcea12e99fa5c077d4f01d7ef1">setReferences</reimplements>
        <param>
          <type>Eigen::Ref&lt; const Eigen::VectorXd &gt;</type>
          <declname>desiredJointValues</declname>
        </param>
        <param>
          <type>const <ref refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1a4d0ff64a201bf8ed884da1c41e3497bc" kindref="member">IRobotControl::ControlMode</ref> &amp;</type>
          <declname>mode</declname>
        </param>
        <param>
          <type>std::optional&lt; Eigen::Ref&lt; const Eigen::VectorXd &gt;&gt;</type>
          <declname>currentJointValues</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Set the desired reference. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>desiredJointValues</parametername>
</parameternamelist>
<parameterdescription>
<para>desired joint values. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>controlMode</parametername>
</parameternamelist>
<parameterdescription>
<para>a control mode for all the joints. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True/False in case of success/failure. </para>
</simplesect>
<simplesect kind="note"><para>In case of position control the values has to be expressed in rad, in case of velocity control in rad/s. If the robot is controlled in torques, the desired joint values are expressed in Nm. If the robot is controlled in PWM, the desired joint values are between -100 and 100. </para>
</simplesect>
<simplesect kind="warning"><para>Call this function if you want to control all the joint with the same control mode. Otherwise call setReferences(Eigen::Ref&lt;const Eigen::VectorXd&gt;, const std::vector&lt;IRobotControl::ControlMode&gt;&amp;). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="BipedalLocomotion/RobotInterface/YarpRobotControl.h" line="151" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a4968e571c4433e54b89a7c83fdfeace2" prot="public" static="no" const="yes" explicit="no" inline="no" final="yes" virt="virtual">
        <type>std::vector&lt; std::string &gt;</type>
        <definition>std::vector&lt;std::string&gt; BipedalLocomotion::RobotInterface::YarpRobotControl::getJointList</definition>
        <argsstring>() const final</argsstring>
        <name>getJointList</name>
        <reimplements refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1a039679ebcb7f4317aebdc1218410639c">getJointList</reimplements>
        <briefdescription>
<para>Get the list of the controlled joints. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A vector containing the name of the controlled joints. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="BipedalLocomotion/RobotInterface/YarpRobotControl.h" line="159" column="17"/>
      </memberdef>
      <memberdef kind="function" id="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a3aa8d45bff0791af4143ab65f0cbd75c" prot="public" static="no" const="yes" explicit="no" inline="no" final="yes" virt="virtual">
        <type>bool</type>
        <definition>bool BipedalLocomotion::RobotInterface::YarpRobotControl::isValid</definition>
        <argsstring>() const final</argsstring>
        <name>isValid</name>
        <reimplements refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1af76dce642b0d3e6a2e54c5a82da8061b">isValid</reimplements>
        <briefdescription>
<para>Check if the class is valid. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>If it is valid you can directly control the robot </para>
</simplesect>
<simplesect kind="return"><para>True if it is valid, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="BipedalLocomotion/RobotInterface/YarpRobotControl.h" line="166" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a2fc36acedb0eb8d541d20a720247f83f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>BipedalLocomotion::RobotInterface::YarpRobotControl::~YarpRobotControl</definition>
        <argsstring>()</argsstring>
        <name>~YarpRobotControl</name>
        <briefdescription>
<para>Destructor. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="BipedalLocomotion/RobotInterface/YarpRobotControl.h" line="171" column="5"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para><ref refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl" kindref="compound">YarpRobotControl</ref> Yarp implementation of the <ref refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl" kindref="compound">IRobotControl</ref> interface. </para>
    </briefdescription>
    <detaileddescription>
<para><simplesect kind="warning"><para>At the current stage only revolute joints are supported. </para>
</simplesect>
</para>
    </detaileddescription>
    <inheritancegraph>
      <node id="1">
        <label>BipedalLocomotion::RobotInterface::YarpRobotControl</label>
        <link refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>BipedalLocomotion::RobotInterface::IRobotControl</label>
        <link refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl"/>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="1">
        <label>BipedalLocomotion::RobotInterface::YarpRobotControl</label>
        <link refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>BipedalLocomotion::RobotInterface::IRobotControl</label>
        <link refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl"/>
      </node>
    </collaborationgraph>
    <location file="BipedalLocomotion/RobotInterface/YarpRobotControl.h" line="33" column="1" bodyfile="BipedalLocomotion/RobotInterface/YarpRobotControl.h" bodystart="34" bodyend="172"/>
    <listofallmembers>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a69d3aac94055729d5fbff666ae1ceb83" prot="public" virt="virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>checkMotionDone</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1a4d0ff64a201bf8ed884da1c41e3497bc" prot="public" virt="non-virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>ControlMode</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a4968e571c4433e54b89a7c83fdfeace2" prot="public" virt="virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>getJointList</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a85dbd7d4b6312bf184bb03054a0240b5" prot="public" virt="virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>initialize</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a3aa8d45bff0791af4143ab65f0cbd75c" prot="public" virt="virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>isValid</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1afafcb9039f5ae8deaac0d3ca95258dd1" prot="private" virt="non-virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>m_pimpl</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1afe135a4312087eb0b666ddbbe3dc25bf" prot="public" virt="virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>setControlMode</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1acdbfb92bd7a2a6bc31ba156600a4ffc9" prot="public" virt="virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>setControlMode</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a227ecb6dd23de07c9513b5f0d6fd3704" prot="public" virt="virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>setControlModeAsync</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a7f2ccdd46451cf760928e527ac2e34b7" prot="public" virt="virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>setControlModeAsync</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a37085e21adddb1bc55193d452623fc82" prot="public" virt="non-virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>setDriver</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a6e9c89964582229a11b5944e02ba6017" prot="public" virt="virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>setReferences</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1ad19d7c06a0f9acd3685075595660a2d7" prot="public" virt="virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>setReferences</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1a5f3690c4c924d5e5fbf590a102bd4234" prot="public" virt="non-virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>shared_ptr</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1a83a31cc243335220b2c218b8534f6851" prot="public" virt="non-virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>unique_ptr</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1a470535808ebda4b9634455c638a1649c" prot="public" virt="non-virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>weak_ptr</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a4ec6b9d2a7d24b197431776c257d7c50" prot="public" virt="non-virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>YarpRobotControl</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1IRobotControl_1a137aaccf768f40582b2df587e55657eb" prot="public" virt="virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>~IRobotControl</name></member>
      <member refid="classBipedalLocomotion_1_1RobotInterface_1_1YarpRobotControl_1a2fc36acedb0eb8d541d20a720247f83f" prot="public" virt="non-virtual"><scope>BipedalLocomotion::RobotInterface::YarpRobotControl</scope><name>~YarpRobotControl</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
